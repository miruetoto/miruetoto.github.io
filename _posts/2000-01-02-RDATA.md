---
title: (정리) Data Analysis with R 
layout: post
---

### About this doc 

- 이 포스트는 해들리위컴의 교재를 참고하여 R에서 데이터를 다루는 전반적인 방법을 요약하였다. 

---
## tidydata: tibble, readr 
---

- 여기에서는 해들리위컴의 교재 7장과 8장을 요약하였다. 

- 7장은 tibble을 소개한다. 티블은 R에서 기본적으로 제공하는 data.frame을 약간 바꾼 것이다. 

- 8장은 readr이라는 패키지를 소개하는데 외부에서 자료를 불러오는 방법에 대하여 다룬다. 

### tibble()

- 컬럼들을 활용하여 티블을 만드는 방법은 아래와 같다. <br/><br/>
```r
## r
library(tidyverse)
x<-c(0,2,3,5,1,4,1,4,2.5)
y<-c(0,0,0,0,1,1,2,2,3)
z<-c(5,4,-4,-5,4,-4,2,-2,0)
tibble(x=x,y=y,z=z)
```
혹은 아래와 같이해도 만들어진다. 
```r
### r
as_tibble(cbind(x,y,z))
```
이게 더 간단해보인다. 둘은 완전히 똑같은 결과를 준다. 즉 아래와 같이 된다. 
```
# A tibble: 9 x 3
      x     y     z
  <dbl> <dbl> <dbl>
1   0       0     5
2   2       0     4
3   3       0    -4
4   5       0    -5
5   1       1     4
6   4       1    -4
7   1       2     2
8   4       2    -2
9   2.5     3     0
```


***데이터불러오기***
- 아래와 같이 csv파일을 읽어온다. <br/><br/>
```r
### r
read_csv("1906_Solardata_result_add.csv")
```
요걸 사용하면 아마 자동으로 티블형태로 읽어와질것이다. 

---
## Data Transformation 
---

- 여기에서는 해들리위컴 교재의 3장, 9장, 10장의 내용을 요약한다. 

- 3장은 기본적으로 하나의 tidy한 티블이 주어졌을때 그것들을 변형하는 방법에 대하여 다룬다. 

- 9장에서는 tidy한 자료가 주어지지 않았을경우 그것을 tidy하게 바꾸는 방법에 대하여 다룬다. 

- 10장에서는 2개 이상의 tidy자료를 다루는 방법에 대하여 다룬다. 


### select()
***select(...,-c())***
- 전체에서 $X_1$,$X_2$,$X_3$를 제외한 결과를 출력하고 싶다고 하자. <br/><br/>
```python
### python
A=initpd("n",n=10,p=5)
push(A,"A")
```
이렇게 해서 파이썬에 정의된 변수 *A*를 R로 푸시한다. 
```r
### r
select(A,-(X1:X3))
select(A,-(1:3))
select(A,c(-1,-2,-3))
```
[여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex4.ipynb)를 참고해보길.

***select(...,start_with())***
- 변수명을 일단 아래와 같이 바꾸자. <br/><br/>
```python
### python
A=initpd("n",n=10,p=5)
A.columns=['XY1','XY2','XZ1','XZ2','X5']
```
변수들을 R로 보내자. 
```python
### python
push(A,"A")
```
"XY"로 시작하는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. 
```r
### r
> library(tidyverse)
> select(A,starts_with("XY"))
```

***select(...,end_with())***
- "2"로 끝나는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. <br/><br/>
```r
### r
> select(A,ends_with("2"))
```

***select(...,contains())***
- "Y"를 포함하는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. 
```r
### r
> select(A,contains("Y"))
```
[여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex5.ipynb)를 참고해보길.

***select(...,everyting())***
- 유용하다. 

- *select()*는 몇 까지 변수를 선택해주지만, 선택되지 않은 변수들은 뺀다. *select()*의 뜻을 고려하면 이는 당연한 현상이다. 

- 그냥 선택된 변수들을 앞으로 모아주는 보여주기만 역할만 하고 싶을때도 있다. 이처럼 몇 개의 변수를 선택하여 앞으로 옮기고, 나머지는 그대로 유지하기 위해서는 아래와 같이 하면 된다. 
```r
### r
> select(A,contains("Z"),everything())
```
이것은 A에서 문자열 "Z"를 포함하는 변수들을 선택하여 앞으로 모아서 보여준다. 전체코드는 [여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex6.ipynb)에 있다. 

***rename()*** 
- 쓸모없다. 
- 특정변수명을 "선택"하여 변수이름을 바꿔주고 싶을 경우가 있다. 아래와 같은 상황을 가정하자.
```python
### python
A=initpd("n",n=10,p=5)
A.columns=['XY1','XY2','XZ1','XZ2','X5']
push(A)
```
변수명 "X"를 변수명 "XZ3"으로 바꾸고 싶다면 아래와 같이 하면 된다. 
```r
### r
> rename(A,XZ3=X5)
```
[여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex7.ipynb)를 참고해보길.

### filter()
***filter()***
- 필터와 같이 활용하는 logical operators는 *>=*, *<=*, *!=*, *!*, *&*, *|*, *%in%*이 있다. 

***filter(..., !is.na())***
- 결측치(*=NA*)를 제거하는 방법은 아래와 같다. 그전에 잠시 결측치에 대하여 이해하여 보자.<br/><br/>
```r
### r
# Let x be Mary's age. We don't know how old she is.
> x <- NA
# Let y be John's age. We don't know how old he is.
> y <- NA
# Are John and Mary the same age?
> x == y
[1] NA
# We don't know!```
```
따라서 *NA*인지 체크하기 위해서 *x==NA* 와 같은 방식으로 체크할 수 없다. 그래서 아래와 같이 한다. 
```r
### r 
> is.na(x)
#> [1] TRUE
```
이제 자료를 만들어서 연습해보자. 아래와 같이 하면 결측치가 제거된 값이 출력된다. 
```r
### r 
> df <- tibble(x = c(1, NA, 3, 4, 5))
> filter(df, !is.na(x))
```
.

### mutate()
***mutate()***
- 기존의 컬럼들을 변화시켜 새로운 컬럼을 만들때 사용한다. 처음 보면 딱히 인상적이진 않다. 우선 아래의 코드로 관심있는 변수를 선택한다. <br/><br/> 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time)
```
선택된 변수는 *year, month, day, dep_delay, arr_delay, distance air_time* 이다. 이제 아래와 같이 *gain, speed* 라는 변수를 추가하자. 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) 
```
추가되는 컬럼의 이름은 *gain, speed* 이다. 좀 더 인상적인 결과는 아래와 같다. 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) %>% 
  filter(!is.na(gain)) %>%
  mutate(gain_zscore = (gain-mean(gain)) / sd(gain))
```
참고로 돌려보니 *gain*값에 NA가 포함되어 있어 이를 *filter()*로 걸러주었다. 마지막 코드의 포인트는 *gain_zscore*인데 이는 *mutate()*가 *mean(), sd()*와 같은 aggregate function들과도 함께 활용될 수 있다는 점을 보여준다. 이 코드는 아래와 같다. 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) %>% 
  mutate(gain_zscore = (gain-mean(gain,na.rm=TRUE)) / sd(gain,na.rm=TRUE))
```
이는 집계함수 안에 *na.rm=TRUE*를 옵션으로 넣어 결측치를 제외하고 집계한 방식이다. 

### group_by() %>% summarize()
***group_by() %>% summarize()***
- 정말 인상적이다. 매우 훌륭한 함수중에 하나이다. 여기에서 *group_by()*랑 *summarize()*는 거의 숙어라고 생각해도 괜찮다. 무조건 같이 쓰는게 좋다. <br/><br/>
```r
### r
> library(nycflights13)
> flights %>% 
  group_by(dest) %>%
  summarize(count=n())
```
집계대상에 *NA*가 포함되면 결과값이 모두 *NA* 되는경우가 있다. 이를 피하기 위해서 집계함수 안에 *na.rm=TRUE*를 옵션으로 넣어주면 편리하다. 
```r
### r
> library(nycflights13)
> flights %>% 
  group_by(year, month, day) %>% 
  summarize(delay = mean(dep_delay, na.rm = TRUE))
```
.

### join

---
## stringr (문자열) 
---
### str_c()
- 이 연산은 *tibble*형 자료에서 *mutate()*과 함께쓰는 것을 추천한다. 기본적으로는 아래와 같이 여러 스칼라 입력을 스칼라로 바꿔주는 기능을 지원한다. 
<br/><br/>
```r
### r
> str_c("x",1,2) # 인풋의개수:6 / 인풋의차원:1
[1] "x12"
```
연산을 아래와 같이 진행된다고 생각하면 편리하다. 
\begin{align}
\begin{bmatrix} 
\mbox{"x"} & 1 & 2
\end{bmatrix} \Longrightarrow 
\mbox{"x12"}
\end{align}
이를 이용해서 아래와 같이 *tibble*형 자료에서 *mutate()*와 함께쓰면 엄청난 위력을 발휘한다. 
```r
### r
> year<-c("2020","2020","2020","2020","2020")
> date<-c("03-24","03-25","04-23","04-25","04-26")
> time<-c("15:00","15:02","16:00","16:00:02","16:00:03")
> ymd_data<-tibble(year=year,date=date,time=time)
> ymd_data
# A tibble: 5 x 3
  year  date  time    
  <chr> <chr> <chr>   
1 2020  03-24 15:00   
2 2020  03-25 15:02   
3 2020  04-23 16:00   
4 2020  04-25 16:00:02
5 2020  04-26 16:00:03
> ymd_data %>% mutate(ymdhms=str_c(year,'/',date,'/',time))
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <chr>              
1 2020  03-24 15:00    2020/03-24/15:00   
2 2020  03-25 15:02    2020/03-25/15:02   
3 2020  04-23 16:00    2020/04-23/16:00   
4 2020  04-25 16:00:02 2020/04-25/16:00:02
5 2020  04-26 16:00:03 2020/04-26/16:00:03
```
이는 *mutate()*가 기본적으로 each observation에 대한 연산을 반복적용하는 기능을 탑재하고 있기 때문에 가능한 것이다. 

- 참고로 *str_c()*는 벡터에도 적용가능하다. 이를 응용하면 1:5까지 숫자들을 생성한뒤 이를 문자열로 바꾸는 방법을 알 수 있다. <br/><br/> 
```r
### r
> str_c(1:5) #인풋의개수:1 / 인풋의차원:5 
[1] "1"  "2"  "3"  "4"  "5" 
```
이는 아래의 느낌이다. 
\begin{align}
\begin{bmatrix} 
1 \\\\ \\
2 \\\\ \\
3 \\\\ \\
4 \\\\ \\
5
\end{bmatrix} \Longrightarrow 
\begin{bmatrix} 
\mbox{"1"} \\\\ \\
\mbox{"2"} \\\\ \\
\mbox{"3"} \\\\ \\
\mbox{"4"} \\\\ \\ 
\mbox{"5"} 
\end{bmatrix}
\end{align}
좀 헷갈릴 수도 있겠지만 *str_c("x",1,2)* 의 경우 각각 차원이 1인 입력값이 3개 전달된 것이고 *str_c(1:5)* 는 차원이 5인 입력값이 1개가 전달된 것으로 해석할 수 있다. 기본적으로 *str_c()*안에 전달되는 입력값들의 *cbind()*로 묶여있다고 생각하면 편리하다. 따라서 
*str_c("x",1,2)* 는 
\begin{align}
["x",1,2]
\end{align} 
와 같은 row-vector가 전달된 셈이고 *str_c(1:5)* 는 
\begin{align}
[1,2,3,4,5]^T
\end{align}
인 col-vector가 전달된 셈이라 해석할 수 있다. 따라서 아래의 코드도 가능하다. 
```r
### r
> str_c(1:5,'-',2:6)
[1] "1-2" "2-3" "3-4" "4-5" "5-6"
```
여기에서 *'-'*는 스칼라이고 다른 입력은 벡터이지만 broad cast가 적용되어 출력이 원하는대로 나왔다. 

- (과제) R에서도 *sprod()*를 구현해보자. 

---
## forcats (팩터형) 
---

---
## lubridate (날짜시간) 
---

### ymd_hms()
- 아래의 자료를 가정하자. <br/><br/>
```r
### r
> year<-c("2020","2020","2020","2020","2020")
> date<-c("03-24","03-25","04-23","04-25","04-26")
> time<-c("15:00:00","15:02:00","16:00:00","16:00:02","16:00:03")
> ymd_data<-tibble(year=year,date=date,time=time)
> ymd_data
# A tibble: 5 x 3
  year  date  time    
  <chr> <chr> <chr>   
1 2020  03-24 15:00:00
2 2020  03-25 15:02:00
3 2020  04-23 16:00:00
4 2020  04-25 16:00:02
5 2020  04-26 16:00:03
> ymd_data <- ymd_data %>% mutate(ymdhms=str_c(year,'/',date,'/',time))
> ymd_data
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <chr>              
1 2020  03-24 15:00:00 2020/03-24/15:00:00
2 2020  03-25 15:02:00 2020/03-25/15:02:00
3 2020  04-23 16:00:00 2020/04-23/16:00:00
4 2020  04-25 16:00:02 2020/04-25/16:00:02
5 2020  04-26 16:00:03 2020/04-26/16:00:03
```
이들을 *dttm*자료형으로 바꾸는 방법은 *ymd_hms()*이다. 
```r
### r
> ymd_data %>% mutate(ymdhms=ymd_hms(ymdhms))
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <dttm>             
1 2020  03-24 15:00:00 2020-03-24 15:00:00
2 2020  03-25 15:02:00 2020-03-25 15:02:00
3 2020  04-23 16:00:00 2020-04-23 16:00:00
4 2020  04-25 16:00:02 2020-04-25 16:00:02
5 2020  04-26 16:00:03 2020-04-26 16:00:03
```
*ymd_hms()*는 *ymd_hm()*,*ydm_hms()*,*ydm_hm()*,*ydm_h()*,*mdy_hms()*,*mdy_hm()*,*mdy_h()*,*dmy_hms()*,*dmy_hm()*,*dmy_h()*와 같이 다양한 버전이 존재하는 장점이 있다. 



---
## magrittr (파이프) 
---

---
##  함수 
---

---
## 벡터
---

---
## purrr
---

