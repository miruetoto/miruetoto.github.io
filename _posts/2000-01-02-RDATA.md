---
title: (정리) Data Analysis with R 
layout: post
---

## About this doc 

- 이 포스트는 해들리위컴의 교재를 참고하여 R에서 데이터를 다루는 전반적인 방법을 요약하였다. 

- 계속 추가할 예정이다. 

---
## $\star$ tidydata: tibble, readr 
---

여기에서는 해들리위컴의 교재 7장과 8장을 요약하였다. 

- 7장은 tibble을 소개한다. 티블은 R에서 기본적으로 제공하는 data.frame을 약간 바꾼 것이다. 

- 8장은 readr이라는 패키지를 소개하는데 외부에서 자료를 불러오는 방법에 대하여 다룬다. 

### *tibble()*

***tibble()***

(1) 함수소개: 티블을 선언하는 함수이다. 

(2) 자료준비: 
```r
> library(tidyverse)
> x<-c(0,2,3,5,1,4,1,4,2.5)
> y<-c(0,0,0,0,1,1,2,2,3)
> z<-c(5,4,-4,-5,4,-4,2,-2,0)
```

(3) 사용방법: 
```r
> tibble(x=x,y=y,z=z)
```
이때 변수이름은 x,y,z가 된다. 


### *as_tibble()*

***as_tibble()***

(1) 함수소개: 다른 데이터를 티블로 바꾸는 함수이다. 이때 컬럼이름이 있는 데이터라야 경고메시지가 뜨지 않는다.

(2) 자료준비: 
```r
> library(tidyverse)
> x<-c(0,2,3,5,1,4,1,4,2.5)
> y<-c(0,0,0,0,1,1,2,2,3)
> z<-c(5,4,-4,-5,4,-4,2,-2,0)
```
cbind()를 활용하여 매트릭스를 만들었다고 가정하자. 
```r
> cbind(x,y,z)
```
이 매트릭스는 컬럼이름이 각각 x,y,z 이다. 컬럼이름이 있으므로 이 매트릭스를 티블로 만들어도 경고가 생기지 않는다. 

(3) 사용방법: 
```r
> as_tibble(cbind(x,y,z))
```

***read_csv()***

(1) 함수소개: csv파일을 읽어오는 함수 

(2) 사용방법: 
```r
> read_csv("1906_Solardata_result_add.csv")
```
요걸 사용하면 자동으로 티블형태로 읽어짐. 

---
## $\star$ Data Transformation 
---

여기에서는 해들리위컴 교재의 3장, 9장, 10장의 내용을 요약한다. 

- 3장은 기본적으로 하나의 tidy한 티블이 주어졌을때 그것들을 변형하는 방법에 대하여 다룬다. 

- 9장에서는 tidy한 자료가 주어지지 않았을경우 그것을 tidy하게 바꾸는 방법에 대하여 다룬다. 

- 10장에서는 2개 이상의 tidy자료를 다루는 방법에 대하여 다룬다. 


### *select()*

***select(...,-c())***

(1) 함수소개
- 특정 컬럼을 선택하고 싶을때 사용한다. 

(2) 자료준비
```r
> A <- itb(10,5)
```
결과는 아래와 같다. 
```r
> A
# A tibble: 10 x 5
        X1     X2     X3     X4      X5
     <dbl>  <dbl>  <dbl>  <dbl>   <dbl>
 1 -0.463  -1.08  -0.125  0.952 -1.58  
 2  1.38   -1.23  -0.129  0.396  1.42  
 3 -0.0462  2.19   0.604  1.51   0.0223
 4 -0.607  -1.65  -0.416 -0.360 -0.336 
 5  0.718   0.115 -0.980 -0.316  0.850 
 6  2.02    1.09   0.869  1.18  -0.795 
 7  0.952  -0.527 -1.31   0.612 -0.303 
 8 -0.307  -1.40  -0.199  0.953 -0.341 
 9  0.0403  0.612 -0.685 -0.858  1.14  
10  0.778   0.464 -1.53  -0.401  0.711 
```

(3) 사용방법: 1,2,3,5번째 변수를 선택하고 싶다면 아래와 같이 한다. 
```r
> A %>% select(1:3,5)
> A %>% select(X1:X3,X5)
```
아래와 같이 해도 괜찮다. 
```r
> A %>% select(1:3,X5)
> A %>% select(X1:X3,5)
```
이렇게 선택한 결과를 B에 저장하고 싶다면 아래와 같이 한다. 
```r
> A %>% select(1:3,5) -> B
> A %>% select(X1:X3,X5) -> B
```

***select(...,-c())***

(1) 함수소개: 특정컬럼을 제외한 결과를 얻고 싶을때 사용한다. 

(2) 자료준비: 아래와 같이 자료를 만든다.
```r
> A <- itb(10,5)
```

(3) 사용방법: 변수 X1,X2,X3를 제외한 출력결과를 얻고 싶다면 아래와 같이 한다. 
```r
> A %>% select(-(X1:X3))
> A %>% select(-(1:3))
> A %>% select(c(-1,-2,-3))
```

***select(...,start_with())***

(1) 함수소개: 특정문자열로 시작하는 컬럼만 선택하고 싶을때 사용한다. 

(2) 자료준비: 
```r
> A <- itb(10,5,vname=c('XY1','XY2','XZ1','XZ2','X5'))
```

(3) 사용방법: "XY"로 시작하는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. 
```r
> A %>% select(starts_with("XY"))
```

***select(...,end_with())***

(1) 함수소개: 특정문자열로 끝나는 컬럼만 선택하고 싶을때 사용한다. 

(2) 자료준비: 아래와 같이 자료를 만든다. 
```r
> A <- itb(10,5,vname=c('XY1','XY2','XZ1','XZ2','X5'))
```

(3) 사용방법: "2"로 끝나는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. 
```r
> A %>% select(ends_with("2"))
```

***select(...,contains())***

(1) 함수소개: 특정문자열을 포함하는 컬럼을 선택하고 싶을때 사용한다. 

(2) 자료준비: 아래와 같이 자료를 만든다. <br/><br/>
```r
> A <- itb(10,5,vname=c('XY1','XY2','XZ1','XZ2','X5'))
```
"Y"를 포함하는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. 
```r
> A %>% select(contains("Y"))
```
.

***select(...,everyting())***

(1) 함수소개: 특정컬럼의 위치를 앞쪽 컬럼으로 이동시키고 싶을때 사용한다. 

- *select()*는 몇 까지 변수를 선택해주지만, 선택되지 않은 변수들은 뺀다. *select()*의 뜻을 고려하면 이는 당연한 현상이다. 

- 하지만 그냥 선택된 변수들을 앞으로 위치만 바꿔서 보고싶을때도 있다. 

(2) 자료준비: 
```r
> A <- itb(10,5,vname=c('XY1','XY2','XZ1','XZ2','X5'))
```

(3) 사용방법: A라는 티블에서 Z가 들어간 변수이름을 모두 선택해서 앞으로 가져오고 싶다면 아래와 같이 하면 된다. *select()*로 변수를 선택하고 *everything()*옵션을 주면 된다. 
```r
> A %>% select(contains("Z"),everything())
```


***rename()*** 

(1) 함수소개: 특정변수의 이름을 바꾸고 싶을때 사용한다. 

(2) 자료준비: 
```r
> A <- itb(10,5,vname=c('XY1','XY2','XZ1','XZ2','X5'))
```

(3) 사용방법: 변수명 "X"를 변수명 "XZ3"으로 바꾸고 싶다면 아래와 같이 하면 된다. 
```r
> A %>% rename(XZ3=X5)
```

### filter()
***filter()***
- 필터와 같이 활용하는 logical operators는 *>=*, *<=*, *!=*, *!*, *&*, *|*, *%in%*이 있다. 

***filter(..., !is.na())***
- 결측치(*=NA*)를 제거하는 방법은 아래와 같다. 그전에 잠시 결측치에 대하여 이해하여 보자.<br/><br/>
```r
# Let x be Mary's age. We don't know how old she is.
> x <- NA
# Let y be John's age. We don't know how old he is.
> y <- NA
# Are John and Mary the same age?
> x == y
[1] NA
# We don't know!```
```
따라서 *NA*인지 체크하기 위해서 *x==NA* 와 같은 방식으로 체크할 수 없다. 그래서 아래와 같이 한다. 
```r
> is.na(x)
#> [1] TRUE
```
이제 자료를 만들어서 연습해보자. 아래와 같이 하면 결측치가 제거된 값이 출력된다. 
```r
> df <- tibble(x = c(1, NA, 3, 4, 5))
> filter(df, !is.na(x))
```
.

### mutate()
***mutate()***
- 기존의 컬럼들을 변화시켜 새로운 컬럼을 만들때 사용한다. 처음 보면 딱히 인상적이진 않다. 우선 아래의 코드로 관심있는 변수를 선택한다. <br/><br/> 
```r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time)
```
선택된 변수는 *year, month, day, dep_delay, arr_delay, distance air_time* 이다. 이제 아래와 같이 *gain, speed* 라는 변수를 추가하자. 
```r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) 
```
추가되는 컬럼의 이름은 *gain, speed* 이다. 좀 더 인상적인 결과는 아래와 같다. 
```r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) %>% 
  filter(!is.na(gain)) %>%
  mutate(gain_zscore = (gain-mean(gain)) / sd(gain))
```
참고로 돌려보니 *gain*값에 NA가 포함되어 있어 이를 *filter()*로 걸러주었다. 마지막 코드의 포인트는 *gain_zscore*인데 이는 *mutate()*가 *mean(), sd()*와 같은 aggregate function들과도 함께 활용될 수 있다는 점을 보여준다. 이 코드는 아래와 같다. 
```r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) %>% 
  mutate(gain_zscore = (gain-mean(gain,na.rm=TRUE)) / sd(gain,na.rm=TRUE))
```
이는 집계함수 안에 *na.rm=TRUE*를 옵션으로 넣어 결측치를 제외하고 집계한 방식이다. 

### group_by() %>% summarize()
***group_by() %>% summarize()***
- 정말 인상적이다. 매우 훌륭한 함수중에 하나이다. 여기에서 *group_by()*랑 *summarize()*는 거의 숙어라고 생각해도 괜찮다. 무조건 같이 쓰는게 좋다. <br/><br/>
```r
> library(nycflights13)
> flights %>% 
  group_by(dest) %>%
  summarize(count=n())
```
집계대상에 *NA*가 포함되면 결과값이 모두 *NA* 되는경우가 있다. 이를 피하기 위해서 집계함수 안에 *na.rm=TRUE*를 옵션으로 넣어주면 편리하다. 
```r
> library(nycflights13)
> flights %>% 
  group_by(year, month, day) %>% 
  summarize(delay = mean(dep_delay, na.rm = TRUE))
```
.

### join

---
## stringr (문자열) 
---
### str_c()

***str_c()***

- 이 연산은 *tibble*형 자료에서 *mutate()*과 함께쓰는 것을 추천한다. 기본적으로는 아래와 같이 여러 스칼라 입력을 스칼라로 바꿔주는 기능을 지원한다. 
<br/><br/>
```r
> str_c("x",1,2) # 인풋의개수:3 / 인풋의차원:1
[1] "x12"
```
연산을 아래와 같이 진행된다고 생각하면 편리하다. 
\begin{align}
\begin{bmatrix} 
\mbox{"x"} & 1 & 2
\end{bmatrix} \Longrightarrow 
\mbox{"x12"}
\end{align}

- 참고로 *str_c()*는 벡터에도 적용가능하다. 이를 응용하면 1:5까지 숫자들을 생성한뒤 이를 문자열로 바꾸는 방법을 알 수 있다. <br/><br/> 
```r
> str_c(1:5) #인풋의개수:1 / 인풋의차원:5 
[1] "1"  "2"  "3"  "4"  "5" 
```
이는 아래의 느낌이다. 
\begin{align}
\begin{bmatrix} 
1 \\\\ \\
2 \\\\ \\
3 \\\\ \\
4 \\\\ \\
5
\end{bmatrix} \Longrightarrow 
\begin{bmatrix} 
\mbox{"1"} \\\\ \\
\mbox{"2"} \\\\ \\
\mbox{"3"} \\\\ \\
\mbox{"4"} \\\\ \\ 
\mbox{"5"} 
\end{bmatrix}
\end{align}
좀 헷갈릴 수도 있겠지만 *str_c("x",1,2)* 의 경우 각각 차원이 1인 입력값이 3개 전달된 것이고 *str_c(1:5)* 는 차원이 5인 입력값이 1개가 전달된 것으로 해석할 수 있다. 기본적으로 *str_c()*안에 전달되는 입력값들의 *cbind()*로 묶여있다고 생각하면 편리하다. 따라서 
*str_c("x",1,2)* 는 
\begin{align}
["x",1,2]
\end{align} 
와 같은 row-vector가 전달된 셈이고 *str_c(1:5)* 는 
\begin{align}
[1,2,3,4,5]^T
\end{align}
인 col-vector가 전달된 셈이라 해석할 수 있다. 따라서 아래의 코드도 가능하다. 
```r
> str_c(1:5,'-',2:6)
[1] "1-2" "2-3" "3-4" "4-5" "5-6"
```
여기에서 *'-'*는 스칼라이고 다른 입력은 벡터이지만 broad cast가 적용되어 출력이 원하는대로 나왔다. 

***mutate(... = str_c(X1,X2,X3))***

- 이를 이용해서 아래와 같이 *tibble*형 자료에서 *mutate()*와 *str_c()* 함께쓰면 마치 엑셀에서 *concat*과 동일한 효과를 주는 함수가 된다. 이번 예제에서는 year,date,time을 각각 스트링으로 저장하고 합치는 예제를 다루어 볼 것이다. <br/><br/>
```r
> year<-c("2020","2020","2020","2020","2020")
> date<-c("03-24","03-25","04-23","04-25","04-26")
> time<-c("15:00:00","15:02:00","16:00:00","16:00:02","16:00:03")
> ymd_data<-tibble(year=year,date=date,time=time)
```
각 자료는 chr으로 만들어져 있다. 출력결과는 아래와 같다. 
```r
> ymd_data
# A tibble: 5 x 3
  year  date  time    
  <chr> <chr> <chr>   
1 2020  03-24 15:00:00   
2 2020  03-25 15:02:00   
3 2020  04-23 16:00:00   
4 2020  04-25 16:00:02
5 2020  04-26 16:00:03
```
이제 year,date,time 각 column의 text를 각각 합치고 구분자는 '/'로 만들어서 새로운 column을 만들어 보자. 새로운 colum의 이름은 ymdhms이다.
```r
> ymd_data %>% mutate(ymdhms=str_c(year,'/',date,'/',time))
```
결과는 아래와 같다. 
```
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <chr>              
1 2020  03-24 15:00    2020/03-24/15:00:00
2 2020  03-25 15:02    2020/03-25/15:02:00
3 2020  04-23 16:00    2020/04-23/16:00:00
4 2020  04-25 16:00:02 2020/04-25/16:00:02
5 2020  04-26 16:00:03 2020/04-26/16:00:03
```
이는 *mutate()*가 기본적으로 each observation에 대한 연산을 반복적용하는 기능을 탑재하고 있기 때문에 가능한 것이다. 


- (과제) R에서도 *sprod()*를 구현해보자. 

---
## forcats (팩터형) 
---

---
## lubridate (날짜시간) 
---

### ymd_hms()

***ymd_hms()***

- 아래의 자료를 가정하자. <br/><br/>
```r
### r
> year<-c("2020","2020","2020","2020","2020")
> date<-c("03-24","03-25","04-23","04-25","04-26")
> time<-c("15:00:00","15:02:00","16:00:00","16:00:02","16:00:03")
> ymd_data<-tibble(year=year,date=date,time=time)
> ymd_data
# A tibble: 5 x 3
  year  date  time    
  <chr> <chr> <chr>   
1 2020  03-24 15:00:00
2 2020  03-25 15:02:00
3 2020  04-23 16:00:00
4 2020  04-25 16:00:02
5 2020  04-26 16:00:03
> ymd_data <- ymd_data %>% mutate(ymdhms=str_c(year,'/',date,'/',time))
> ymd_data
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <chr>              
1 2020  03-24 15:00:00 2020/03-24/15:00:00
2 2020  03-25 15:02:00 2020/03-25/15:02:00
3 2020  04-23 16:00:00 2020/04-23/16:00:00
4 2020  04-25 16:00:02 2020/04-25/16:00:02
5 2020  04-26 16:00:03 2020/04-26/16:00:03
```
이들을 *dttm*자료형으로 바꾸는 방법은 *ymd_hms()*이다. 
```r
### r
> ymd_data %>% mutate(ymdhms=ymd_hms(ymdhms))
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <dttm>             
1 2020  03-24 15:00:00 2020-03-24 15:00:00
2 2020  03-25 15:02:00 2020-03-25 15:02:00
3 2020  04-23 16:00:00 2020-04-23 16:00:00
4 2020  04-25 16:00:02 2020-04-25 16:00:02
5 2020  04-26 16:00:03 2020-04-26 16:00:03
```
*ymd_hms()*는 *ymd_hm()*,*ydm_hms()*,*ydm_hm()*,*ydm_h()*,*mdy_hms()*,*mdy_hm()*,*mdy_h()*,*dmy_hms()*,*dmy_hm()*,*dmy_h()*와 같이 다양한 버전이 존재하는 장점이 있다. 



---
## magrittr (파이프) 
---

---
##  함수 
---

---
## 벡터
---

---
## purrr
---

