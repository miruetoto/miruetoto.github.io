---
title: (리뷰) Data center cooling using model-predictive control
layout: post 
---

## About this doc 
- 이 포스트는 아래논문의 리뷰임. <br/>
Lazic, N., Boutilier, C., Lu, T., Wong, E., Roy, B., Ryu, M. K., \& Imwalle, G. (2018). Data center cooling using model-predictive control. In Advances in Neural Information Processing Systems (pp. 3818-3827).

## Model Predictive control 
- 저자들은 PID에 존재하는 불필요한 성분들을 제거하기 위해서 **MPC**를 도입한다고 주장한다. 여기에서 **MPC**는 model predictive control의 약자이다. PID는 무엇의 약자인지 모르겠음. 

- 저자들이 멀하고 싶은지 알기 위하여 잠시 배경지식을 공부하여 보자. 저자들이 하고 싶은건 서버실의 온도제어이다. 서버실의 온도를 제어하는 방법은 대충 다음과 같은것 같다. **(1)** 서버실밖의 쿨링타워에서는 차가운 물을 서버실로 보낸다. 이때 찬물의 온도를 **EWT** 라고 한다. **(2)** 차가운 물이 관을 타고 가서 서버실에 있는 에어컨에 도착한다. **(3)** 에어컨 에서는 서버실의 (뜨거운) 공기를 흡수한다. 그리고 (2)의 과정에 의해 도착한 차가운 물을 이용해 흡수된 (뜨거운) 공기를 찬공기로 만들어 배출한다. 이때 에어컨으로 흡수되는 뜨거운 공기의 온도를 **EAT** 라고 한다. 그리고 에어컨이 내뿜는 차가운 공기의 온도를 **LAT** 라고 한다. **(4-1)** 이때 에어컨이 찬공기를 그냥 보내는 것이 아니다. 서버실 전체에 골고루 찬공기가 갈 수 있게 적절한 바람세기로 보내야 한다. 그래서 서버실의 공기압력을 체크하여 어느정도의 강도로 팬을 돌릴지 결정한다. 공기압력은 여기에서 **DP** 로 정의하고 팬의강도는 **fan speed** 라고 정의한다. **(4-2)** 또한 얼마만큼 냉각을 시켜 공기를 보내야 할지 결정해야 하므로 서버실 온도 **CAT** 와 에어컨으로 유입되는 공기의 온도 **EAT** 를 보고 벨브를 얼마나 열지 결정한다. 이때 벨브를 얼마나 여는지를 측정하는 변수를 **valve opening** 라고 정의한다. **(5)** 에어컨에 차가운물이 들어가서 찬공기를 만들었으므로 에어컨에서 배출된 물은 들어온물보다 따듯한 물일 것이다. 이때의 물의 온도를 **LWT** 라고 한다. 이 물은 다시 관을 타고 서버실 밖의 쿨링타워로 빠져나간다. **(6)** 쿨링타워로 들어온 물은 다시 냉각되어서 서버실로 보내진다. 

- 위에서 정의된 각 약어의 의미는 아래와 같다. <br/>
**EWT**: entering water temperature <br/>
**EAT**: entering air temperature <br/>
**LAT**: leaving air temperature <br/>
**LWT**: leaving water temperature <br/>
**DP**: differential air pressure <br/>
**CAT**: cold-aisle temperature <br/>

- 지금까지 언급된 변수들은 크게 3가지 카테고리에 들어갈 수 있다. 첫번째는 **상태변수** 이다. 상태변수는 우리가 예측하고 싶거나 조절하고 싶은 변수이다. 예를들면 서버실의 현재 온도 **CAT**, 에어컨으로 들어오는 공기의 온도 **EAT**, 에어컨에서 빠져나가는 공기 온도 **LAT**, 그리고 마지막으로 서버실의 압력상태(이걸 알아야 얼만큼 강하게 팬을 돌려야 할지 결정할 수 있음)를 의미하는 **DP** 가 있다. 두번째 변수는 **제어변수** 이다. 제어변수는 상태변수에 따라서 우리가 구체적으로 어떠한 액션을 해야할지를 결정하는 변수이다. 제어변수에 해당하는것은 에어컨에서 찬물의 밸브를 얼마나 열지 결정하는 **valve opening**, 그리고 에어컨에서 나오는 바람의 세기를 결정하는 **fan speed**가 있다. 마지막 변수는 **장애변수** 이다. 장애변수의 의미는 우리가 컨트롤하지 못하는 어떠한 외부요인에 의해 휘둘리는 변수라고 생각하면 된다. 장애변수의 예는 서버실로 들어가는 물의 온도인 **EWT** 와 **server power useage** 가 있다. **EWT**가 장애변수라는 것은 우리가 쿨링타워까지는 제어하지 않는다는 의미와 동치이다. 

- 저자들의 목적은 다음과 같다. (1) 상태변수들을 모델링해서 다음시점에서 각 상태변수들이 어떠한 값을 가질지 예측하고 (2) 각 상태변수들이 특정한 값(set point)을 가지도록 **동시에** 제어하며 (3) 제어의 **jointly optimize** , 즉 **매우 적은 에너지만으로** 여러가지 상태변수를 원하는 값으로 동시에 제어하는 방법을 개발하는 것이다. 

- 고정된 시간 $t$에 대한 모델은 아래와 같다. 
\begin{align}
{\bf x}[t]=\sum_{k=1}^{T}A_k{\bf x}[t-k]+\sum_{k=1}^{T}B_k {\bf u}[t-k] + C {\bf d}[t-1]
\end{align}
여기에서 ${\bf x}[t]$, ${\bf u}[t]$ 그리고 ${\bf d}[t]$ 는 각각 **상태변수**, **제어변수**, **장애변수** 을 의미하는 vector이다. 또한 $A_k$, $B_k$, $C$는 각각 차원에 맞는 매트릭스이다. 

- 고정된 시간 $t$에 대하여 ${\bf x}[t]$가 벡터인 이유는 **상태변수** 에 해당하는 변수값이 여러개이기 때문이다. 논문에서는 DP(=differential air pressure), CAT(cold-aisle temerature), EAT(entering air temperature), LAT(leaving air temperature) 를 상태변수로 두었다. 따라서 고정된 $t$에 대하여 ${\bf x}[t]$는 4차원 벡터이다. 마찬가지 논리로 **제어변수**는 fan speed, valve opening 2개가 있으므로 ${\bf u}[t]$는 2차원 벡터이다. 장애변수는 EWT와 server power useage가 있으므로 ${\bf d}[t]$ 역시 2차원 벡터이다. 

- 그리고  ${\bf x}[t]$, ${\bf u}[t]$, ${\bf d}[t]$ 의 차원에 맞는 $A_k,~B_k,~C$를 각각 구해보면 $A_k=4\times 4$, $B_k$와 $C$는 $4 \times 2$ 행렬임을 알 수 있다. 

- 복잡해 보이는 아래식은 결국 회귀분석의 하나의 응용형태에 불과하다. 
\begin{align}
{\bf x}[t]=\sum_{k=1}^{T}A_k{\bf x}[t-k]+\sum_{k=1}^{T}B_k {\bf u}[t-k] + C {\bf d}[t-1]
\end{align}
총 $n$번의 시간동안 관측치를 모으게 된다면 위의 모델은 아래로 간략화하여 정리할 수 있다. 
\begin{align}
{\bf y}={\bf X}{\bf \beta}+\epsilon
\end{align}
여기에서 ${\bf y}$는 $n\times 4$ 인 행렬이고 ${\bf X}$는 $n \times (6T+2)$ 인 행렬이며 $\bf \beta$는 $(6T+2) \times 4$ 행렬이다. 오차항 $\epsilon$은 $n \times 4$행렬이다. 구체적으로는 아래와 같다. 
\begin{align}
{\bf y}=\begin{bmatrix}
{\bf x}[t] \\\\ \\\\ 
{\bf x}[t-1] \\\\ \\\\ 
\dots \\\\ \\\\ 
{\bf x}[t-n+1)]
\end{bmatrix},
{\bf X}=\begin{bmatrix}
{\bf x}[t-1] & \dots & {\bf x}[t-T] & {\bf u}[t-1] & \dots & {\bf u}[t-T] & {\bf d}[t-1] \\\\ \\\\ 
{\bf x}[t-2] & \dots & {\bf x}[t-T-1] & {\bf u}[t-2] & \dots & {\bf u}[t-T-1] & {\bf d}[t-2] \\\\ \\\\ 
\dots \\\\ \\\\ 
x[t-n] & u[t-n] & d[t-n] 
\end{bmatrix}, 
\beta=\begin{bmatrix}
A_1 \\\\ \\\\ 
\dots \\\\ \\\\ 
A_T \\\\ \\\\ 
B_1 \\\\ \\\\ 
\dots \\\\ \\\\ 
B_T \\\\ \\\\ 
C \\\\ \\\\ 
\end{bmatrix}
\end{align}
따라서 $n$개의 관측치를 모으기만 하면 쉽게 $\beta$를 구할수 있다. 


