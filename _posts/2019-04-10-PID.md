---
layout: post
title: (정리) PID
---

### About this doc 
- 이 문서는 PID에 대한 개념을 잡기 위한 문서이다. 

- 이 문서는 아래 책을 요약한 것이다. 나름 PID제어쪽에서 바이블에 가까운 책인것 같다. (아니면 제대로 된 책이 없던가, 솔직히 말해서 잘 쓴 책인지는 모르겠다. 설명이 너무 이상함.) 2019.4.10일 기준 6096회의 인용횟수를 자랑한다. <br/>
Åström, K. J., \& Hägglund, T. (1995). PID controllers: theory, design, and tuning (Vol. 2). Research Triangle Park, NC: Instrument society of America.

### Process Model 

- **PV**(process variable)을 $y(t)$라고 하고 **SP**(set point)를 $y_{sp}(t)$라고 하자. 둘 사이의 차이를 **컨트롤에러**라고 정의하고 기호로는 $e(t)$라고 하자.
\begin{align}
e(t)=y_{sp}(t)-y(t)
\end{align}

- 우리는 여기에서 2개의 장치(?)를 고려할 것이다. (1) 하나는 **컨르롤러**이고 (2) 다른 하나는 **프로세스**이다. 컨트롤러는 컨트롤에러 $e(t)$를 입력으로 받아서 컨트롤아웃풋 $u(t)$를 출력하는 어떠한 장치이다. 우리 입장에서는 함수라고 생각하면 된다. 여기에서 컨트롤 아웃풋 $u(t)$는 우리가 조작할 수 있는 어떠한 변수를 의미한다. 예를들면 벨브의 세기라든가, 팬의세기와 같은것들이 $u(t)$로 측정된다.  프로세스는 컨트롤아웃풋 $u(t)$를 입력으로 받아서 **일정시간 뒤에** $y(t+1)$을 출력한다. 이건 자연현상이다. 즉 밸브를 얼만큼 열었을때($u(t)$가 정해졌을때) 온도변화가 얼만큼 일어나게 된다는 사실을 알려주는 장치가 프로세스이다.  

- 프로세스의 출력에는 오차가 있다고 한다. 이것은 자연현상에 따른 오차일수도있고 (즉 입력을 똑같이 줘도 출력이 달라지는 경우) 관측에 따른 오차일수도 있다. (실제로 자연은 $y(t+1)$를 출력으로 줬는데 우리는 $\tilde y(t+1)$를 관측한 경우) 아무튼 자연현상에는 변덕이 심해서 $u(t)$를 알고 있어도 $y(t+1)$가 얼마가 나올지 우리는 알 수가 없다. 이러한 프로세스를 모델링 하는것은 시계열분석을 활용할수도 있고 스펙트럴 어날리시스를 활용할 수도 있다. (사실 그게 그거임) 일반적으로 스펙트럴 어날리시스는 정상시계열이 아닌 경우 분석하기 힘들지만 자연현상은 대부분 정상시계열이기 때문에 스펙트럴 어날리시스로 모델링해도 **충분**할것 같긴하다. 

- 프로세스는 그 특성에 따라서 다시 2가지로 나누어지는데 하나는 **스태틱-프로세스(static process)**이고 다른 하나는 **다이나믹-프로세스(dynamic process)** 이다. 스태틱-프로세스는 컨트롤아웃풋 $u(t)$가 주어질때 프로세스-베리어블 $y(t)$가 선형으로 나오는 경우를 의미하는것 같다. 예컨데 $u(t)$와 $y(t)$간에 아래와 같은 관계식이 성립한다면 스태틱-프로세스이다.
\begin{align}
y(t)=0.5 u(t) 
\end{align}
스태틱-프로세스의 특징은 프로세스 출력 $y(t)$는 오직 현재시점 $t$의 프로세스 입력 $u(t)$에만 의존한다는 것이다. 위의식을 이산형으로 표현하면 아래와 같이 된다. 
\begin{align}
y[t]=0.5 u[t]
\end{align}
진짜 이 경우는 너무 깔끔하게 $y[t]$를 구할 수 있다. 반면에 다이나믹-프로세스는 프로세스 출력 $y(t)$가 현재시점 $t$에 의존하지 않는모델을 의미한다. 구글링을 좀 해보면 다이나믹-프로세스는 (1) 프로세스 출력 $y(t)$와 $u(t)$사이의 관계식에 아래와 같이 미분텀이 포함된 경우 
\begin{align}
y(t)=0.5 u(t) + 0.2 \frac{d}{dt}u(t)
\end{align}
라고 설명하기도 하고 (2) 프로세스 출력 $y(t)$가 현재시점의 $u(t)$값 뿐만 아니라 과거시점의 $u(t-1)$값까지 이용하는 프로세스라고 설명하기도 한다. 잘 생각해보면 두 설명은 같은소리를 하고 있는데, 그 이유는 위의 식의 이산자료의 표현은 아래와 같고 
\begin{align}
y[t]=0.5 u[t] + 0.2 \left( u[t]-u[t-1] \right) 
\end{align}
이는 결국 아래처럼 쓸 수 있는데 
\begin{align}
y[t]=0.7 u[t] - 0.2 u[t-1] 
\end{align}
이는 결국 (2)를 의미하기 때문이다. 

- 내가 이해하기로 이 책의 범위에서 다이나믹-프로세스는 **LTI시스템**으로 이해해도 무방하다. 챕터 2.3에 보면 다이나믹-프로세스의 행동특징을 포착하는것은 매우 어려운 일이라고 설명하면서 우리는 이 책에서 LTI시스템에 한정하여 다이내믹 프로세스를 이해하겠다고 밝힌다. 우리가 관심 있어하는 프로세스가 그냥 단순히 LTI시스템일 뿐이라고 한다면 문제는 매우 단순해 진다. 왜냐하면 LTI시스템은 결국 AR류의 모델이기 때문이다. LTI시스템을 쉽게 설명하면 (1) 리니어(linear)하며 (2) 타임-인배리언트(time-invariant)한 성질을 가진 시스템을 의미한다. 이중에서 (1)은 그냥 선형시스템이라는 의미이고 (2)는 정상성(stationary)을 만족한다는 의미이다. 결국 이 모델은 일반적인 AR류에서 벗어나지 못한다고 볼 수 있다. 

- 실제 현상을 모델링하는데 이러한 AR류의 모델로 충분한지 그렇지 않은지 모르겠다. 하지만 우선 PID 컨트롤은 AR류의 모델을 기본으로 하여 이론이 정리되어 있다는 점에서 큰 한계점을 가진다. AR류의 모델은 프로세스가 정상성을 가지는 경우에는 완벽하게 동작하지만 실제현상이 반드시 정상성을 보장하지는 않는다. 단순하게 생각하여 모델에 계절성이 있는경우만 해도 정상성가정을 만족하지 못한다. 또한 분산이 시간에 따라 조금씩 변화하는 Garch와 같은 모델도 비정상시계열의 대표적 사례이다. 게다가 외부효과가 있는 경우는 (갑자기 어떠한 이벤트로 인하여 시계열 전체가 흔들리게 되는 경우) 이러한 정상성가정이 깨지게 되어서 모델링이 불가능하게 된다. 

- 아무튼 이러한 경우를 모두 없다고 생각하고 프로세스에 대한 모델링을 하겠다. 이 책에서는 다이나믹-프로세스를 LTI에 한정하였으므로 우리도 이러한 방식을 따라간다. LTI시스템은 결국 아래와 같은 모양으로 표현되는 식을 의미한다. 
\begin{align}
y[t]-\sum_{l=1}^{L_1}a_ly[t-l]=\sum_{l=0}^{L_2}b_lu[t-l]
\end{align}
그리고 $a_1=0,a_2=0,\dots,a_{L_1}=0$과 같은 경우에는 이 시스템을 **FIR필터**라고 부르며 그 외에는 **IIR필터**라고 부른다. 우리는 일단 **FIR필터**는 고려하지 않는다. 우리는 **IIR필터**를 고려하며 그중에서도 특히 아래와 같은 모델을 고려한다. 
\begin{align}
y[t]=u[t]+a_1y[t-1]+a_2y[t-2]+\dots+a_Ly[t-L]
\end{align}

- 기본적으로 LTI시스템은 임펄스응답(impulse response)에 의하여 **유일하게(uniquely)** 결정할 수 있다. 여기에서 임펄스응답은 입력으로 임펄스입력 $\delta(t)$를 넣었을 경우 즉 $u(t)=\delta(t)$일 경우 시스템의 출력 $y(t)$를 의미하며 기호로는 $h(t)$와 같이 사용한다. 임펄스응답이 어떻게 LTI시스템을 유일하게 결정할 수 있다는 것인지 아래의 예제를 통하여 살펴보도록 하자. 우리가 관심이 있는 시스템이 아래와 같다고 하자. 
\begin{align}
y[t]=2 u[t] + 0.5 y[t-1] + 0.2 y[t-2]
\end{align}
위의 시스템에 대한 임펄스응답 $h[t]$은 아래의 식을 만족한다. 
\begin{align}
h[t]=2 \delta[t] + 0.5 h[t-1] + 0.2h[t-2]
\end{align}
위의 수식에 **z-transform**을 취하면 아래와 같다. 
\begin{align}
H(z)=2+ 0.5 z H(z) + 0.2 z^2 H(z)
\end{align}
따라서 이 경우 
\begin{align}
H(z)=\frac{2}{1-0.5z-0.2 z^2}
\end{align}
와 같이 된다. 위의 식을 자세히 보면 임의의 LTI시스템 
\begin{align}
y[t]-\sum_{l=1}^{L_1}a_ly[n-l]=\sum_{l=0}^{L_2}b_lu[n-l]
\end{align}
의 임펄스응답은 아래와 같음을 알 수 있다. 
\begin{align}
h[t]={\cal Z}^{-1}\left \\{\frac{\sum_{l=0}^{L_2}z^lb_l}{1-\sum_{l=1}^{L_1}z^la_l} \right \\}
\end{align}

- 이산신호가 아닌 연속신호의 경우는 위의 예제가 아래와 같이 수정된다. 
\begin{align}
y(t)=2 u(t) + 0.5 \frac{d}{dt} y(t) +  0.2 \left(\frac{d}{dt}\right)^2 y(t)
\end{align}
위의 식에서 라플라스 변환을 취하면 아래와 같이 된다. 
\begin{align}
Y(s)= 2 U(s) + 0.5 s Y(s) + 0.2 s^2 Y(s)
\end{align}
이 경우 $Y(s)=H(s)U(s)$를 만족하는 $H(s)$는 아래와 같다. 
\begin{align}
H(s)=\frac{2}{1-0.5s-0.2s^2}
\end{align}
따라서 일반적인 수식 
\begin{align}
y(t)- \sum_{l=1}^{L_1}a_ly^{(n-l)}(t)=\sum_{l=0}^{L_2}b_lu^{(n-l)}(t)
\end{align}
에 대한 임펄스 응답은 아래와 같이 정리할 수 있다. (단 여기에서 $y^{(1)}(t)=\frac{d}{dt}y(t)$를 의미함.) 
\begin{align}
h(t)={\cal L}^{-1}\left \\{\frac{\sum_{l=0}^{L_2}s^lb_l}{1-\sum_{l=1}^{L_1}s^la_l} \right \\}.
\end{align}

- 결론적으로 우리가 관심있는 LTI시스템은 **임펄스응답**만 알면 끝난다. 하지만 실제로는 입펄스입력을 넣는것 자체가 불가능하므로 임펄스응답을 구하는것은 불가능하다. 우리가 넣을 수 있는 입력은 스텝입력이고 따라서 우리가 구할수 있는 응답도 **스텝응답**이다. 책의 챕터 2.4에 보면 스텝응답을 보고 계수를 추론하는 방법이 나온다. 우선 가장 간단한 스텝입력 
\begin{align}
u(t)=\int_{-\infty}^{t}\delta(\tau)d\tau
\end{align}
를 넣었을 경우를 생각해보자. 이것에 대한 라플라스 변환은 
\begin{align}
U(s)=\frac{1}{s}
\end{align}
와 같이 된다. $Y(s)=U(s)H(s)$이므로 스텝응답 $s(t)$은 아래와 같이 표현할 수 있다. 
\begin{align}
s(t)={\cal L}^{-1}\left \\{ \frac{1}{s}H(s) \right \\}.
\end{align}
만약에 우리가 관심이 있는 시스템이 $H(s)=\frac{b_0}{1-a_1s}$라고 하자. 그렇다면 $s(t)$는 아래와 같이 표현가능하다. 
\begin{align}
s(t)=b_0 \int_{-\infty}^{t}\delta(\tau)d\tau + a_1 \frac{d}{dt} s(t)
\end{align}
**시스템이 안정적이라는 가정하에(반드시 이 가정이 필요함)** 아래가 성립한다. 
\begin{align}
\frac{d}{dt}s(t)=s'(t) \rightarrow 0 ~ as ~ t \rightarrow \infty
\end{align}
따라서 $s(\infty)=b_0$가 성립한다. 

- 잠시 IIR시스템의 approximation에 대하여 정리하고 넘어가자. IIR시스템의 경우 보통 
\begin{align}
H(s)=\frac{1}{a_0+a_1 s+a_2 s^2+\dots+a_L s^L}
\end{align}
과 같은 형태로 표현할 수 있다. 하지만 실제로 그렇다고 하더라도 아래와 같은 모델을 고려하는 것이 더 **실용적**이다. 
\begin{align}
H(s)=\frac{1}{a_0+a_1 s+a_2 s^2+\dots+a_L s^L}e^{-t_0 s}
\end{align}
이러한 모델은 모든 응답이 특정한 시간 $t_0$ 이후에 나타나는 아래와 같은 시스템을 설명한다. 
\begin{align}
y[t]=a_0x[t-t_0]+\dots+a_L x[t-L-t_0]
\end{align}
여기에서 $t_0$를 책에서는 **dead time**이라고 표현하였다. 왜 이러한 시스템을 고려하는 것일까? 이유는 예제 2.1에 설명되어 있다. 실제 모델이 $H(s)=\frac{1}{(s+1)^8}$과 같다고 하자. 이러한 시스템은 $t=2$에서 거의 응답이 없게 된다. (교재의 그림 2.7참고) 이러한 실제모델을 2개의 파라메터를 사용하여 적합시킨다고 하자. 즉 
\begin{align}
H(s)\approx \frac{1}{a_0+a_1s}
\end{align}
라고 생각하고 $a_0$과 $a_1$을 구한다고 생각하자. 그런데 $(s+1)^8=1+8s+\dots+s^8$과 같이 전개될 것이므로 당연히 $a_0=1$, $a_1=8$ 이면 괜찮은것 같다는 생각이 든다. (책에서는 어떻게 구하긴 한거같은데 아무튼 $a_0$와 $a_1$의 값은 같음) 아무튼 $H(s)\approx \frac{1}{1+8s}$ 와 같이 생각하고 적합을 시키면 피본다. 왜냐하면 그림 2.7을 보면 실제 $H(s)=\frac{1}{(s+1)^2}$ 이 설명하는 시스템 상으로는 $t=2$에서 출력이 거의 $0$ 인데 $H(s)\approx \frac{1}{1+8s}$ 와 같이 적합시킨다면 $t=2$에서 출력이 매우 높게 나오기 때문이다. 사실 이미 파라메터 2개를 가지고 9개의 파라메터로 표현되는 시스템 $H(s)=\frac{1}{(s+1)^8}$을 표현하는것 자체가 노답이다. 하지만 어쩔수 없이 파라메터 2개로 표현해야 한다면 아래와 같은 모델로 표현해보는것이 결론적으로 좋다고 설명되어 있다. 
\begin{align}
H(s) \approx \frac{1}{a_0s}e^{-t_0s}
\end{align}
이런 모델은 데드타임 $t_0$이후에 출력이 나오는 시스템을 의미한다. 

- 사실 위의 두 시스템 모두 $H(s)=\frac{1}{(s+1)^8}$을 표현하기에는 불충분하다. 하지만 서로의 장단점이 매우 뚜렷하다는 점에서 흥미롭다. 첫번째 시스템 $H(s)\approx \frac{1}{a_0+a_1s}$를 살펴보자. 이 시스템은 $u(t)$가 들어왔을 경우 
\begin{align}
y(t), y(t+1), y(t+2), \dots 
\end{align}
와 같은 초기의 $y(t)$값은 잘 못맞추지만 후반에는 잘맞추는 특징이 있다. (그림 2.7 참고) 즉 
\begin{align}
y(t+100),\dots,y(t+1000),\dots, y(t+100000000000),\dots 
\end{align} 
등으로 갈수로 잘 맞춘다. 두번째 시스템 $H(s) \approx \frac{1}{a_0s}e^{-t_0s}$은 반대이다. 초기값은 잘 맞추는데 (이거야 그냥 0으로 맞추면 되니깐) 뒤로 갈수록 잘 못맞춘다. 그런데 우리의 입장에서는 먼 훗날 아무리 잘 맞추는 거 보다야 초반에 잘맞추는게 좋기 때문에 두번째 시스템을 더 선호하게 된다. 


