---
title: (정리) Data Analysis
layout: post
---

### About this doc 

- 이 포스트는 해들리위컴의 교재를 참고하여 데이터를 다루는 전반적인 방법을 요약하였다. R환경, python환경, 그리고 둘을 결합한 rpy2에서의 데이터작업을 한다. 

---
## 1. Data Transformation: dplyr, pandas
---

### 1.1. Select columns with select()
***select(...,-c())***
- 전체에서 $X_1$,$X_2$,$X_3$를 제외한 결과를 출력하고 싶다고 하자. <br/><br/>
```python
### python
A=initpd("n",n=10,p=5)
push(A,"A")
```
이렇게 해서 파이썬에 정의된 변수 *A*를 R로 푸시한다. 
```r
### r
select(A,-(X1:X3))
select(A,-(1:3))
select(A,c(-1,-2,-3))
```
[여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex4.ipynb)를 참고해보길.

***select(...,start_with())***
- 변수명을 일단 아래와 같이 바꾸자. <br/><br/>
```python
### python
A=initpd("n",n=10,p=5)
A.columns=['XY1','XY2','XZ1','XZ2','X5']
```
변수들을 R로 보내자. 
```python
### python
push(A,"A")
```
"XY"로 시작하는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. 
```r
### r
> library(tidyverse)
> select(A,starts_with("XY"))
```

***select(...,end_with())***
- "2"로 끝나는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. <br/><br/>
```r
### r
> select(A,ends_with("2"))
```

***select(...,contains())***
- "Y"를 포함하는 변수들을 뽑기 위해서는 아래와 같이 하면 된다. 
```r
### r
> select(A,contains("Y"))
```
[여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex5.ipynb)를 참고해보길.

***select(...,everyting())***
- 유용하다. 

- *select()*는 몇 까지 변수를 선택해주지만, 선택되지 않은 변수들은 뺀다. *select()*의 뜻을 고려하면 이는 당연한 현상이다. 

- 그냥 선택된 변수들을 앞으로 모아주는 보여주기만 역할만 하고 싶을때도 있다. 이처럼 몇 개의 변수를 선택하여 앞으로 옮기고, 나머지는 그대로 유지하기 위해서는 아래와 같이 하면 된다. 
```r
### r
> select(A,contains("Z"),everything())
```
이것은 A에서 문자열 "Z"를 포함하는 변수들을 선택하여 앞으로 모아서 보여준다. 전체코드는 [여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex6.ipynb)에 있다. 

***rename()*** 
- 쓸모없다. 
- 특정변수명을 "선택"하여 변수이름을 바꿔주고 싶을 경우가 있다. 아래와 같은 상황을 가정하자.
```python
### python
A=initpd("n",n=10,p=5)
A.columns=['XY1','XY2','XZ1','XZ2','X5']
push(A)
```
변수명 "X"를 변수명 "XZ3"으로 바꾸고 싶다면 아래와 같이 하면 된다. 
```r
### r
> rename(A,XZ3=X5)
```
[여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex7.ipynb)를 참고해보길.

--- 

***4 ways for selecting columns in python***
- 아래와 같은 데이터프레임을 만들었다고 하자. <br/><br/>
```python
### python
A=initpd("n",n=10,p=5)
```
파이썬에서 첫번째 변수를 선택하는 방법은 아래처럼 총 4개의 방법이 있다. 
```python
### python
A.X1
A[['X1']]
A.loc[:,'X1']
A.iloc[:,0]
```
예제는 [여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex1.ipynb)를 참고해라. 이제부터 위에 제시된 4개의 방법의 장단점을 살펴보자. 

***A.X1***
- 이 방법은 가장 간단해 보인다. 하지만 컬럼이름에 "."이 들어가면 쓸 수 없다는 치명적인 단점이 있다. 즉 컬럼이름이 "X1"인 경우는 쓸 수 있지만 컬럼이름이 "X.1"와 같은 경우 쓸 수 없다. 

***A[['X1']]***
- 이 방법은 위와 달리 컬럼이름에 "."이 있어도 쓸 수 있다. 또한 위의 방법과 달리 여러개의 컬럼을 즉 아래가 가능하다. <br/><br/>
```python
### python
A[['X1','X2']]
```
하지만 슬라이싱을 활용하여 여러컬럼을 선택할 수는 없다. 즉 아래가 불가능하다. 
```python
### python
A['X1':'X3']
```
.

***A.loc[:,'X1']***
- 기본적으로 컬럼이름에 "."이 포함되어도 사용할 수 있다. 또한 여러개의 컬럼을 호출할 수 있다. 즉 아래가 가능하다. <br/><br/>
```python
### python
A.loc[:,['X1','X2']]
```
그리고 슬라이싱을 통하여 여러개의 컬럼을 선택할수 있다. 즉 아래가 가능하다. 
```python
### python
A.loc[:,'X1':'X3']
```
하지만 컬럼의 index-set을 정의하고 접근하는것은 불가능하다. 예를들어 홀수번째 컬럼들만 출력하는 코드를 짤 수 없다. 


***A.iloc[:,0]***
- 슬라이싱이 가능하다. 하지만 ***loc***의 경우와 그 결과가 다르다. 1,2,3번째 변수를 추출하고 싶을 경우 <br/><br/> 
```python
### python
A.loc[:,'X1':'X3']
```
와 같이 하지만 같은 결과를 ***iloc***으로 구현하려면 
```python
### python
A.iloc[:,0:3]
```
와 같이 해야한다. 즉 ***loc***의 경우 양쪽인덱스가 모두 포함되지만 ***iloc***의 경우 마지막 인덱스는 포함되지 않는다. 

- [여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex2.ipynb)를 참고해보길.


- 아래와 같이 index-set을 정의하고 접근하는것도 가능하다. 예를들어 홀수번째 번수들만 출력하는 코드를 다음과 같이 구현가능하다. <br/><br/> 
```python
### python
pindex=cc(1,3)*2-2
A.iloc[:,pindex]
```
[여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex3.ipynb)를 참고해보길.

### 1.2. Filter rows with filter()
***filter()***
- 필터와 같이 활용하는 logical operators는 *>=*, *<=*, *!=*, *!*, *&*, *|*, *%in%*이 있다. 

***filter(..., !is.na())***
- 결측치(*=NA*)를 제거하는 방법은 아래와 같다. 그전에 잠시 결측치에 대하여 이해하여 보자.<br/><br/>
```r
### r
# Let x be Mary's age. We don't know how old she is.
> x <- NA
# Let y be John's age. We don't know how old he is.
> y <- NA
# Are John and Mary the same age?
> x == y
[1] NA
# We don't know!```
```
따라서 *NA*인지 체크하기 위해서 *x==NA* 와 같은 방식으로 체크할 수 없다. 그래서 아래와 같이 한다. 
```r
### r 
> is.na(x)
#> [1] TRUE
```
이제 자료를 만들어서 연습해보자. 아래와 같이 하면 결측치가 제거된 값이 출력된다. 
```r
### r 
> df <- tibble(x = c(1, NA, 3, 4, 5))
> filter(df, !is.na(x))
```
.

### 1.3. Add new variables with mutate()
***mutate()***
- 기존의 컬럼들을 변화시켜 새로운 컬럼을 만들때 사용한다. 처음 보면 딱히 인상적이진 않다. 우선 아래의 코드로 관심있는 변수를 선택한다. <br/><br/> 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time)
```
선택된 변수는 *year, month, day, dep_delay, arr_delay, distance air_time* 이다. 이제 아래와 같이 *gain, speed* 라는 변수를 추가하자. 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) 
```
추가되는 컬럼의 이름은 *gain, speed* 이다. 좀 더 인상적인 결과는 아래와 같다. 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) %>% 
  filter(!is.na(gain)) %>%
  mutate(gain_zscore = (gain-mean(gain)) / sd(gain))
```
참고로 돌려보니 *gain*값에 NA가 포함되어 있어 이를 *filter()*로 걸러주었다. 마지막 코드의 포인트는 *gain_zscore*인데 이는 *mutate()*가 *mean(), sd()*와 같은 aggregate function들과도 함께 활용될 수 있다는 점을 보여준다. 이 코드는 아래와 같다. 
```r
### r
> library(nycflights13)
> flights %>% 
  select(year:day,ends_with("delay"), distance, air_time) %>% 
  mutate(gain = dep_delay - arr_delay,
         speed = distance / air_time * 60) %>% 
  mutate(gain_zscore = (gain-mean(gain,na.rm=TRUE)) / sd(gain,na.rm=TRUE))
```
이는 집계함수 안에 *na.rm=TRUE*를 옵션으로 넣어 결측치를 제외하고 집계한 방식이다. 

### 1.4. Grouped summaries 
***group_by() %>% summarise()***
- 정말 인상적이다. 매우 훌륭한 함수중에 하나이다. <br/><br/>
```r
### r
> library(nycflights13)
> flights %>% 
  group_by(dest) %>%
  summarise(count=n())
```
집계대상에 *NA*가 포함되면 결과값이 모두 *NA* 되는경우가 있다. 이를 피하기 위해서 집계함수 안에 *na.rm=TRUE*를 옵션으로 넣어주면 편리하다. 
```r
### r
> library(nycflights13)
> flights %>% 
  group_by(year, month, day) %>% 
  summarise(delay = mean(dep_delay, na.rm = TRUE))
```
.

### 1.5. Join

***pd.merge***
- 아래와 같은 예제를 고려하여보자. <br/><br/>
```python
### python
V=['Ant-man','Hulk','Iron-man']
Vpd=pd.DataFrame({'nodename':V})
boxofficepd=pd.DataFrame({'nodename':['Ant-man','Iron-man','Hulk'],'box-office':[100,300,50]})
pd.merge(Vpd,boxofficepd)
```
여기에서는 2개의 데이터프레임 *Vpd*, *boxofficepd* 가 있으며 공통적으로 'nodename' 열을 가지고 있다. *pd.merge()* 함수는 각 데이터프레임이 'nodename' 열을 가지고 있다는 것을 알고 자동으로 이 열을 키로 사용해 조인한다. **이때 'nodename'의 순서가 이 예제처럼 다를지라도 pd.merge() 는 정확하게 이를 맞추어 정렬한다.** 

- 거창하게 써놓았는데 그냥 **내부조인**을 파이썬에서 한 것이다. 위 예제의 코드는 [여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/datatransformation_ex8.ipynb)를 참고해라.


---
## tidydata: tibble, readr, tidyr
---

***make tibble*** 
- 컬럼들을 활용하여 티블을 만드는 방법은 아래와 같다. <br/><br/>
```r
## r
> library(tidyverse)
> x<-c(0,2,3,5,1,4,1,4,2.5)
> y<-c(0,0,0,0,1,1,2,2,3)
> z<-c(5,4,-4,-5,4,-4,2,-2,0)
> tibble(x=x,y=y,z=z)
```
혹은 아래와 같이해도 만들어진다. 
```r
### r
> as_tibble(cbind(x,y,z))
```
이게 더 간단해보인다. 둘은 완전히 똑같은 결과를 준다. 예제코드는 [여기](https://github.com/miruetoto/miruetoto.github.io/blob/master/my_code/DataAnal/tidydata_ex1.ipynb)를 참고해라. 


***데이터불러오기***
- 아래와 같이 csv파일을 읽어온다. <br/><br/>
```r
### r
> read_csv("1906_Solardata_result_add.csv")
```
요걸 사용하면 아마 자동으로 티블형태로 읽어와질것이다. 

---
## stringr (문자열) 
---
### str_c()
- 이 연산은 *tibble*형 자료에서 *mutate()*과 함께쓰는 것을 추천한다. 기본적으로는 아래와 같이 여러 스칼라 입력을 스칼라로 바꿔주는 기능을 지원한다. 
<br/><br/>
```r
### r
> str_c("x",1,2) # 인풋의개수:6 / 인풋의차원:1
[1] "x12"
```
연산을 아래와 같이 진행된다고 생각하면 편리하다. 
\begin{align}
\begin{bmatrix} 
\mbox{"x"} & 1 & 2
\end{bmatrix} \Longrightarrow 
\mbox{"x12"}
\end{align}
이를 이용해서 아래와 같이 *tibble*형 자료에서 *mutate()*와 함께쓰면 엄청난 위력을 발휘한다. 
```r
### r
> year<-c("2020","2020","2020","2020","2020")
> date<-c("03-24","03-25","04-23","04-25","04-26")
> time<-c("15:00","15:02","16:00","16:00:02","16:00:03")
> ymd_data<-tibble(year=year,date=date,time=time)
> ymd_data
# A tibble: 5 x 3
  year  date  time    
  <chr> <chr> <chr>   
1 2020  03-24 15:00   
2 2020  03-25 15:02   
3 2020  04-23 16:00   
4 2020  04-25 16:00:02
5 2020  04-26 16:00:03
> ymd_data %>% mutate(ymdhms=str_c(year,'/',date,'/',time))
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <chr>              
1 2020  03-24 15:00    2020/03-24/15:00   
2 2020  03-25 15:02    2020/03-25/15:02   
3 2020  04-23 16:00    2020/04-23/16:00   
4 2020  04-25 16:00:02 2020/04-25/16:00:02
5 2020  04-26 16:00:03 2020/04-26/16:00:03
```
이는 *mutate()*가 기본적으로 each observation에 대한 연산을 반복적용하는 기능을 탑재하고 있기 때문에 가능한 것이다. 

- 참고로 *str_c()*는 벡터에도 적용가능하다. 이를 응용하면 1:5까지 숫자들을 생성한뒤 이를 문자열로 바꾸는 방법을 알 수 있다. <br/><br/> 
```r
### r
> str_c(1:5) #인풋의개수:1 / 인풋의차원:5 
[1] "1"  "2"  "3"  "4"  "5" 
```
이는 아래의 느낌이다. 
\begin{align}
\begin{bmatrix} 
1 \\\\ \\
2 \\\\ \\
3 \\\\ \\
4 \\\\ \\
5
\end{bmatrix} \Longrightarrow 
\begin{bmatrix} 
\mbox{"1"} \\\\ \\
\mbox{"2"} \\\\ \\
\mbox{"3"} \\\\ \\
\mbox{"4"} \\\\ \\ 
\mbox{"5"} 
\end{bmatrix}
\end{align}
좀 헷갈릴 수도 있겠지만 *str_c("x",1,2)* 의 경우 각각 차원이 1인 입력값이 3개 전달된 것이고 *str_c(1:5)* 는 차원이 5인 입력값이 1개가 전달된 것으로 해석할 수 있다. 기본적으로 *str_c()*안에 전달되는 입력값들의 *cbind()*로 묶여있다고 생각하면 편리하다. 따라서 
*str_c("x",1,2)* 는 
\begin{align}
["x",1,2]
\end{align} 
와 같은 row-vector가 전달된 셈이고 *str_c(1:5)* 는 
\begin{align}
[1,2,3,4,5]^T
\end{align}
인 col-vector가 전달된 셈이라 해석할 수 있다. 따라서 아래의 코드도 가능하다. 
```r
### r
> str_c(1:5,'-',2:6)
[1] "1-2" "2-3" "3-4" "4-5" "5-6"
```
여기에서 *'-'*는 스칼라이고 다른 입력은 벡터이지만 broad cast가 적용되어 출력이 원하는대로 나왔다. 

- (과제) R에서도 *sprod()*를 구현해보자. 

---
## forcats (팩터형) 
---

---
## lubridate (날짜시간) 
---

### as_date(), as_datetime(), ymd_hms()
- 아래의 자료를 가정하자. <br/><br/>
```r
### r
> year<-c("2020","2020","2020","2020","2020")
> date<-c("03-24","03-25","04-23","04-25","04-26")
> time<-c("15:00:00","15:02:00","16:00:00","16:00:02","16:00:03")
> ymd_data<-tibble(year=year,date=date,time=time)
> ymd_data
# A tibble: 5 x 3
  year  date  time    
  <chr> <chr> <chr>   
1 2020  03-24 15:00:00
2 2020  03-25 15:02:00
3 2020  04-23 16:00:00
4 2020  04-25 16:00:02
5 2020  04-26 16:00:03
> ymd_data <- ymd_data %>% mutate(ymdhms=str_c(year,'/',date,'/',time))
> ymd_data
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <chr>              
1 2020  03-24 15:00:00 2020/03-24/15:00:00
2 2020  03-25 15:02:00 2020/03-25/15:02:00
3 2020  04-23 16:00:00 2020/04-23/16:00:00
4 2020  04-25 16:00:02 2020/04-25/16:00:02
5 2020  04-26 16:00:03 2020/04-26/16:00:03
```
이들을 *dttm*자료형으로 바꾸는 방법은 *as_datetime()*, *ymd_hms()*이다. 
```r
### r
> ymd_data %>% mutate(ymdhms=as_date(ymdhms))
# A tibble: 5 x 4
  year  date  time     ymdhms    
  <chr> <chr> <chr>    <date>    
1 2020  03-24 15:00:00 2020-03-24
2 2020  03-25 15:02:00 2020-03-25
3 2020  04-23 16:00:00 2020-04-23
4 2020  04-25 16:00:02 2020-04-25
5 2020  04-26 16:00:03 2020-04-26
> ymd_data %>% mutate(ymdhms=as_datetime(ymdhms))
# A tibble: 5 x 4
  year  date  time     ymdhms             
  <chr> <chr> <chr>    <dttm>             
1 2020  03-24 15:00:00 2020-03-24 15:00:00
2 2020  03-25 15:02:00 2020-03-25 15:02:00
3 2020  04-23 16:00:00 2020-04-23 16:00:00
4 2020  04-25 16:00:02 2020-04-25 16:00:02
5 2020  04-26 16:00:03 2020-04-26 16:00:03

```




---
## magrittr (파이프) 
---

---
##  함수 
---

---
### 16. 벡터
---

---
### 17. purrr
---

